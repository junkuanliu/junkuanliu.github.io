<!DOCTYPE html>
<html lang="en" dir="auto">

<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="robots" content="index, follow">
  <title>VLM + RL + Data (Environment) = GUI Agent | junkuan</title>
  <meta name="description" content="Why reinforcement learning, rich environments, and high-quality data are converging to make dependable GUI agents possible." />
  <meta name="author" content="Junkuan (Benjamin) Liu">
  <link rel="canonical" href="https://junkuanliu.github.io/posts/vlm-rl-gui-agent/" />
  <link crossorigin="anonymous" href="/assets/css/stylesheet.min.51b2420ff5ea1215cdf584af7ba59d5fea94201c33f25109d6448c7271631316.css" integrity="sha256-UbJCD/XqEhXN9YSve6WdX+qUIBwz8lEJ1kSMcnFjExY=" rel="preload stylesheet" as="style">
  <link rel="icon" type="image/png" sizes="16x16" href="https://junkuanliu.github.io/favicon-16x16.png">
  <link rel="icon" type="image/png" sizes="32x32" href="https://junkuanliu.github.io/favicon-32x32.png">
  <link rel="apple-touch-icon" href="https://junkuanliu.github.io/apple-touch-icon.png">
  <link rel="mask-icon" href="https://junkuanliu.github.io/safari-pinned-tab.svg">
  <meta name="theme-color" content="#2e2e33">
  <meta name="msapplication-TileColor" content="#2e2e33">
  <meta property="og:title" content="VLM + RL + Data (Environment) = GUI Agent" />
  <meta property="og:description" content="A field note on how reinforcement learning, environments, and data pipelines are converging toward dependable GUI agents." />
  <meta property="og:type" content="article" />
  <meta property="og:url" content="https://junkuanliu.github.io/posts/vlm-rl-gui-agent/" />
  <meta property="article:published_time" content="2025-09-18T00:00:00-04:00" />
  <meta name="twitter:card" content="summary_large_image" />
  <meta name="twitter:title" content="VLM + RL + Data (Environment) = GUI Agent" />
  <meta name="twitter:description" content="Why reinforcement learning, rich environments, and high-quality data are converging to make dependable GUI agents possible." />
  <script type="application/ld+json">
  {
    "@context": "https://schema.org",
    "@type": "BlogPosting",
    "headline": "VLM + RL + Data (Environment) = GUI Agent",
    "description": "Why reinforcement learning, rich environments, and high-quality data are converging to make dependable GUI agents possible.",
    "datePublished": "2025-09-18T00:00:00-04:00",
    "dateModified": "2025-09-18T00:00:00-04:00",
    "author": {
      "@type": "Person",
      "name": "Junkuan (Benjamin) Liu"
    },
    "mainEntityOfPage": {
      "@type": "WebPage",
      "@id": "https://junkuanliu.github.io/posts/vlm-rl-gui-agent/"
    }
  }
  </script>
  <link rel="alternate" hreflang="en" href="https://junkuanliu.github.io/posts/vlm-rl-gui-agent/" />
  <noscript>
    <style>
      #theme-toggle,
      .top-link {
        display: none;
      }
    </style>
    <style>
      @media (prefers-color-scheme: dark) {
        :root {
          --theme: rgb(29, 30, 32);
          --entry: rgb(46, 46, 51);
          --primary: rgb(218, 218, 219);
          --secondary: rgb(155, 156, 157);
          --tertiary: rgb(65, 66, 68);
          --content: rgb(196, 196, 197);
          --hljs-bg: rgb(46, 46, 51);
          --code-bg: rgb(55, 56, 62);
          --border: rgb(51, 51, 51);
        }

        .list {
          background: var(--theme);
        }

        .list:not(.dark)::-webkit-scrollbar-track {
          background: 0 0;
        }

        .list:not(.dark)::-webkit-scrollbar-thumb {
          border-color: var(--theme);
        }
      }
    </style>
  </noscript>
  <style>
    /* Reference list numbering as [1], [2], ... */
    .ref-list { list-style: none; padding-left: 0; counter-reset: ref; }
    .ref-list > li { counter-increment: ref; margin: 6px 0; }
    .ref-list > li::before { content: "[" counter(ref) "] "; font-weight: 600; }
  </style>
  <script>
    window.MathJax = {
      tex: {
        inlineMath: [['\\(', '\\)'], ['$', '$']],
        displayMath: [['\\[', '\\]'], ['$$', '$$']],
        processEscapes: true,
        tags: 'ams'
      },
      options: {
        skipHtmlTags: ['script','noscript','style','textarea','pre','code']
      },
      svg: { fontCache: 'global' }
    };
  </script>
  <script defer src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script>
</head>

<body class="" id="top">
  <script>
    if (localStorage.getItem("pref-theme") === "dark") {
      document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
      document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
      document.body.classList.add('dark');
    }
  </script>

  <header class="header">
    <nav class="nav">
      <div class="logo">
        <a href="https://junkuanliu.github.io/" accesskey="h" title="junkuan (Alt + H)">junkuan</a>
        <span class="logo-switches">
          <button id="theme-toggle" accesskey="t" title="(Alt + T)">
            <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
              <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
            </svg>
            <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
              <circle cx="12" cy="12" r="5"></circle>
              <line x1="12" y1="1" x2="12" y2="3"></line>
              <line x1="12" y1="21" x2="12" y2="23"></line>
              <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
              <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
              <line x1="1" y1="12" x2="3" y2="12"></line>
              <line x1="21" y1="12" x2="23" y2="12"></line>
              <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
              <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
            </svg>
          </button>
          <ul class="lang-switch"><li>|</li></ul>
        </span>
      </div>
      <ul id="menu">
        <li><a href="https://junkuanliu.github.io/page/profile/" title="Profile"><span>Profile</span></a></li>
        <li><a href="https://junkuanliu.github.io/posts/" title="Blog"><span class="active">Blog</span></a></li>
        <li><a href="https://junkuanliu.github.io/archives/" title="Archive"><span>Archive</span></a></li>
        <li><a href="https://junkuanliu.github.io/search/" title="Search (Alt + /)" accesskey="/"><span>Search</span></a></li>
        <li><a href="https://junkuanliu.github.io/tags/" title="Tags"><span>Tags</span></a></li>
        <li><a href="https://junkuanliu.github.io/faq/" title="FAQ"><span>FAQ</span></a></li>
      </ul>
    </nav>
  </header>

  <main class="main">
    <article class="post-single">
      <header class="post-header">
        <div class="breadcrumbs">
          <a href="https://junkuanliu.github.io/">Home</a>
          <span class="breadcrumbs-separator">/</span>
          <a href="https://junkuanliu.github.io/posts/">Blog</a>
        </div>
        <h1 class="post-title">VLM + RL + Data (Environment) = GUI Agent</h1>
        <div class="post-meta">
          <span class="post-date">September 18, 2025</span>
          <span class="meta-separator">•</span>
          <span class="post-reading-time">8 min read</span>
        </div>
      </header>

      <div class="post-content">
        <p>Since GPT-3, teaching AI to operate computers and phones has been a persistent ambition. Many systems have been proposed—some tool-centric, some rule-driven, some fully end-to-end. Given the breadth of prior work, in this post, I focus on one route that is increasingly convergent in the literature: use <strong>reinforcement learning (RL)</strong> to train a <strong>vision-language model (VLM)</strong> to act as a GUI agent end-to-end.</p>

        <figure>
          <video src="/posts/vlm-rl-gui-agent/media/uitars_demo.mp4" controls preload="metadata" playsinline style="max-width:100%;border-radius:6px"></video>
          <figcaption>Demo Video of a GUI Agent (UI-TARS2) <a href="#ref-14">[14]</a></figcaption>
        </figure>

        

        <h2 id="vision-language-model">Vision-Language Model</h2>
        <p>A straightforward way to automate GUI action is to use prompt engineering with a VLM and, in multi-stage designs, delegate planning to one model and grounding to another [<a href="#ref-1">1</a>–<a href="#ref-2">2</a>]. This decomposition can be useful in simple settings, but it relies on rigid interfaces between models: if the planner’s outputs deviate even slightly from what the grounding model expects, the whole pipeline may break. Such fragility makes cross-domain transfer difficult and limits robustness under interface changes. For this reason, the field is now converging on unified architectures where a single vision-language model carries perception, reasoning, and action. In addition, hand-crafted pipelines tend to plateau quickly, whereas learned, end-to-end systems continue to improve with scale and interaction signal. Reading “The Bitter Lesson” provides useful historical intuition for why general, learned systems ultimately win out over manual decomposition <a href="#ref-3">[3]</a>.</p>

        <figure>
          <img src="/posts/vlm-rl-gui-agent/media/gui-agent-overview.png" alt="Conceptual diagram of a vision-language model GUI agent pipeline." loading="lazy" style="max-width:100%;border-radius:6px">
          <figcaption>Architecture of GUI agents powered by vision-language models.</figcaption>
        </figure>

        
        <p>General-purpose VLMs bring strong priors from vast pre-training corpora, but GUI control is a distinct domain. Screens are high-resolution and densely populated with small, function-bearing elements; models often miss tiny icons without special treatment [<a href="#ref-4">4</a>–<a href="#ref-5">5</a>]. Semantics depend on hierarchical layout and affordances rather than natural-image statistics, and robust localization remains hard under resolution constraints [<a href="#ref-6">6</a>–<a href="#ref-7">7</a>]. GUI interfaces also evolve at runtime: pop-ups, notifications, and layout drift introduce non-stationarity and noise that perception must handle gracefully [<a href="#ref-8">8</a>–<a href="#ref-10">10</a>]. Finally, tasks unfold over long horizons with stateful dependencies across applications; scalable, reliable long-horizon reasoning remains open <a href="#ref-10">[10]</a>.</p>
        <p>In response to these domain-specific challenges, the community has built GUI-centric perception datasets and models and then used supervised fine-tuning (SFT) to specialize VLMs for precise grounding and action mapping. High-resolution and small-box localization are explicitly targeted by Aguvis and ScreenSpot-style resources <a href="#ref-4">[4]</a>, <a href="#ref-12">[12]</a>, while structural understanding of layout and affordances is stressed by WebSRC <a href="#ref-6">[6]</a>. At the same time, OS-ATLAS curates a cross-platform atlas of OS-level elements and tasks and releases baseline models trained via SFT to improve grounded understanding across desktop domains <a href="#ref-7">[7]</a>. Concretely, the OS-ATLAS project reports consistent gains of its SFT models on the cross-app evaluations and supplies reproducible training and evaluation recipes, illustrating the typical “pretrain for perception → SFT for domain specialization” pipeline.</p>

        <figure>
          <img src="/posts/vlm-rl-gui-agent/media/vlm-table.png" alt="Table summarizing supervised fine-tuning results for GUI perception datasets." loading="lazy">
          <figcaption>Specialized datasets push VLMs toward GUI fluency, yet reliability gaps remain.</figcaption>
        </figure>

        <p>However, the table above makes the limitation of SFT clear: even with domain-specialized pretraining and supervised fine-tuning, models remain far from human reliability on multi-application desktop workflows. With the rise of verifiable-reward RL—training regimes that compute rule-based task signals from the environment—RL is increasingly applied to GUI agents to optimize behavior over trajectories rather than single steps <a href="#ref-11">[11]</a>.</p>

        <h2 id="reinforcement-learning">Reinforcement Learning</h2>
        <p>RL has a long history in sequential decision-making. When training a GUI agent, the interaction process between the agent and its environment is naturally formalized as a Markov Decision Process (MDP), denoted as M = {S, A, T, r, γ}. In this formulation, the state space S corresponds to possible screen observations and instructions; the action space A includes clicks, text entry, scrolling, or higher-level API calls; the transition function T models how the interface evolves; and the reward function r provides scalar feedback. The objective is to learn a policy π(a∣s) that maximizes expected return. This framing makes reinforcement learning a natural fit: unlike supervised fine-tuning, which depends on annotated trajectories, RL can directly optimize behavior through interaction, particularly in long-horizon, multi-application workflows [<a href="#ref-12">12</a>–<a href="#ref-13">13</a>].</p>

        <figure>
          <p style="text-align:center">
            $$
            R_c = \begin{cases}
              1, & \text{if } \mathbf{C} \in \mathcal{B}, \\
              0, & \text{else.}
            \end{cases}
            \qquad
            (\mathbf{C}=(x_t, y_t),\; \mathcal{B} = [x_{\min}, x_{\max}] \times [y_{\min}, y_{\max}])
            $$
          </p>
          <figcaption>Verifiable reward.</figcaption>
        </figure>

        <p><strong>Verifiable reward.</strong> To use RL for training a GUI agent, we adopt a minimal, verifiable signal at each step. The <em>state</em> is the pair \((q_t, I_t)\) of instruction and screenshot; the <em>action</em> is the model’s next-token output decoded as a click point \(\mathbf{C}=(x_t,y_t)\). Given a ground-truth bounding box \(\mathcal{B}\) for the target element, the reward pays \(R_c=1\) if the predicted point lands inside \(\mathcal{B}\) and \(R_c=0\) otherwise—keeping the objective tightly aligned with correct interaction while remaining trivial to compute at scale <a href="#ref-19">[19]</a>.</p>
        <p><strong>Reward shaping.</strong> The binary indicator is only a starting point. We can shape rewards to stabilize learning and capture task geometry—for example a <em>Gaussian reward</em> around the box centroid \(c_{\mathcal{B}}\) (higher credit as the click approaches the center), <em>format rewards</em> that grant credit when model-generated output matches required patterns, and penalties for invalid or off-screen actions.</p>
        <p>The benefits of RL in this setting are straightforward. GUI tasks incur compounding error and delayed credit assignment; RL directly optimizes long-term return rather than step-wise imitation. Rule-based or “verifiable” rewards allow programmatic checks of progress and completion, reducing the rick of reward hacking. <a href="#ref-13">[13]</a>. Empirically, these ingredients translate into better adaptivity under layout drift, more reliable error recovery, and improved cross-application transfer relative to SFT-only baselines.</p>
        <p>People have already begun to apply RL to GUI agents, and the initial results are encouraging. For instance, the UI-TARS2 integrates multimodal perception with reinforcement signals to improve robustness under UI drift and long-horizon tasks, demonstrating clear gains over supervised approaches across domains <a href="#ref-13">[13]</a>, <a href="#ref-14">[14]</a>. Similarly, benchmarks such as OSWorld show that RL-trained models can generalize better than SFT alone, achieving higher success rates on multi-step workflows across applications <a href="#ref-10">[10]</a>. These results suggest that interaction-driven optimization is beginning to narrow the gap toward human-like reliability.</p>
        <p>At the same time, the main obstacles exposed by these RL studies point beyond the optimizer. High-quality, up-to-date trajectories and learning-grade environments are scarce; many public corpora exhibit noise, outdated UI states, or narrow coverage <a href="#ref-12">[12]</a>, <a href="#ref-13">[13]</a>. Environment ecosystems typically fall into three families—static replicas (e.g., screenshot snapshots), simulated or self-hosted websites (e.g., MiniWoB, WebArena/VisualWebArena), and real-world execution platforms (e.g., OSWorld, AndroidWorld/MobileAgentBench)—each trading off fidelity, controllability, and cost [<a href="#ref-8">8</a>–<a href="#ref-10">10</a>], <a href="#ref-12">[12]</a>, [<a href="#ref-15">15</a>–<a href="#ref-17">17</a>]. <strong>However, none of them yet meet the bar for scalable, verifiable, and economical data generation at once</strong>—each compromises fidelity, controllability, or cost. In short, as RL moves from proofs-of-concept to realistic settings, data and environments—not just algorithms—will increasingly determine progress.</p>

        <h2 id="data-in-rl">Data for Reinforcement Learning</h2>
        <p>When applying RL to GUI agents, it is tempting to keep tuning the optimizer or add intricate reward shaping. But after taking a careful look at failure cases, it shows that many errors stem from <em>signal quality</em> rather than the policy update itself: <strong> incorrect bounding boxes</strong> that misalign clicks and targets, <strong>one-to-many instructions</strong> where a natural-language command can correspond to multiple valid UI elements but the dataset only marks one. In other words, the algorithm may be “good enough” on clean loops; what holds back reliability is the quality and timeliness of the interaction data.</p>
        <p><strong>Beyond environments, however, there is still no generally accepted, scalable method to acquire large-scale, high-quality trajectory data for RL.</strong> Existing collection pipelines either introduce too much noise (e.g., weakly verified outcomes, model generated ambiguous instruction, incorrect bounding box) or fail to scale economically to the volumes needed for robust long-horizon learning. In practice, this means policies trained with interaction remain constrained not only by algorithmic choices but by the lack of reliable, progress-aware trajectories at scale.</p>
        <p><strong>From a data perspective, the most promising path is to engineer environments as data generators</strong>, not because environments are the only solution, but because they can operationalize what high-quality trajectories require. If an environment can (i) <strong>verify</strong> terminal and intermediate conditions programmatically (reducing label noise), (ii) <strong>control</strong> drift and perturbations to expose robustness gaps systematically, and (iii) <strong>scale</strong> via parallel, replayable execution, then it becomes a practical instrument for producing large volumes of reliable, progress-aware interaction data—precisely the bottleneck identified above. This does not preclude complementary routes (e.g., policy-guided logging with consent, rule-based reward extraction, or offline value modeling). The unifying principle is: <strong>Data quality is not merely a matter of collecting samples, but a system-level property—realized through systematic data curation or well-designed environments.</strong>.</p>

        <h2 id="references">References</h2>
        <ol class="ref-list">
          <li id="ref-1">OmniParser. “Structured UI Representations from Screenshots for GUI Grounding.” 2024. <a href="https://github.com/microsoft/OmniParser" target="_blank" rel="noopener">https://github.com/microsoft/OmniParser</a></li>
          <li id="ref-2">SeeClick. “SeeClick: Harnessing General-Purpose Models for Click-Through GUI Grounding.” Findings of ACL, 2024. <a href="https://aclanthology.org/2024.acl-long.505.pdf" target="_blank" rel="noopener">https://aclanthology.org/2024.acl-long.505.pdf</a></li>
          <li id="ref-3">Sutton, R. S. “The Bitter Lesson.” 2019. <a href="https://www.cs.utexas.edu/~eunsol/courses/data/bitter_lesson.pdf" target="_blank" rel="noopener">https://www.cs.utexas.edu/~eunsol/courses/data/bitter_lesson.pdf</a></li>
          <li id="ref-4">ScreenSpot-Pro. “GUI Grounding for Professional High-Resolution Computer Use.” 2025. <a href="https://arxiv.org/abs/2504.07981" target="_blank" rel="noopener">https://arxiv.org/abs/2504.07981</a></li>
          <li id="ref-5">CogAgent. “CogAgent: A Visual–Language Model for GUI Perception and Small-Element Localization.” 2024. <a href="https://arxiv.org/abs/2312.08914" target="_blank" rel="noopener">https://arxiv.org/abs/2312.08914</a></li>
          <li id="ref-6">WebSRC. “Web-based Structural Reading Comprehension.” EMNLP, 2021. <a href="https://arxiv.org/abs/2101.09465" target="_blank" rel="noopener">https://arxiv.org/abs/2101.09465</a></li>
          <li id="ref-7">OS-ATLAS. “A Cross-Platform Operating-System GUI Atlas for Grounded Understanding.” Project &amp; preprint, 2024. <a href="https://osatlas.github.io/" target="_blank" rel="noopener">https://osatlas.github.io/</a></li>
          <li id="ref-8">WebArena. “A Realistic Web Environment for Building Autonomous Agents.” Project &amp; arXiv preprint, 2023. <a href="https://arxiv.org/abs/2307.13854" target="_blank" rel="noopener">https://arxiv.org/abs/2307.13854</a> — <a href="https://webarena.dev" target="_blank" rel="noopener">https://webarena.dev</a></li>
          <li id="ref-9">VisualWebArena. “Evaluating Multimodal Agents on Realistic Visual Web Tasks.” 2024. <a href="https://arxiv.org/abs/2401.13649" target="_blank" rel="noopener">https://arxiv.org/abs/2401.13649</a></li>
          <li id="ref-10">OSWorld. “Benchmarking Multimodal Agents for Open-Ended Tasks in Real Computer Environments.” NeurIPS Datasets &amp; Benchmarks / arXiv preprint, 2024. <a href="https://arxiv.org/abs/2404.07972" target="_blank" rel="noopener">https://arxiv.org/abs/2404.07972</a> — <a href="https://os-world.github.io" target="_blank" rel="noopener">https://os-world.github.io</a></li>
          <li id="ref-11">DeepSeek-R1. “Incentivizing Reasoning via Verifiable Rewards.” 2025. <a href="https://arxiv.org/abs/2501.12948" target="_blank" rel="noopener">https://arxiv.org/abs/2501.12948</a></li>
          <li id="ref-12">Survey (Perception–Exploration–Planning–Interaction). “A Survey on (M)LLM-Based GUI Agents.” 2025. <a href="https://arxiv.org/html/2504.13865v1" target="_blank" rel="noopener">https://arxiv.org/html/2504.13865v1</a></li>
          <li id="ref-13">Survey (RL-Enhanced GUI Agents). “A Survey on GUI Agents with Foundation Models Enhanced by Reinforcement Learning.” 2025. <a href="https://arxiv.org/pdf/2504.20464" target="_blank" rel="noopener">https://arxiv.org/pdf/2504.20464</a></li>
          <li id="ref-14">UI-TARS / UI-TARS2. “Unified Perception-to-Action Mobile/Android Agents with Reinforcement Optimization.” 2024–2025. <a href="https://arxiv.org/abs/2509.02544" target="_blank" rel="noopener">https://arxiv.org/abs/2509.02544</a></li>
          <li id="ref-15">MiniWoB / MiniWoB++. “World of Bits: An Open-Domain Platform for Web-Based Agents (incl. MiniWoB).” ICML, 2017. <a href="https://arxiv.org/abs/1707.06690" target="_blank" rel="noopener">https://arxiv.org/abs/1707.06690</a></li>
          <li id="ref-16">AndroidWorld. “A Dynamic Real-Device Benchmarking Environment for Autonomous Agents.” 2024. <a href="https://arxiv.org/abs/2405.14573" target="_blank" rel="noopener">https://arxiv.org/abs/2405.14573</a></li>
          <li id="ref-17">MobileAgentBench. “A Benchmark for Mobile LLM Agents on Real Devices.” 2024. <a href="https://arxiv.org/abs/2406.08184" target="_blank" rel="noopener">https://arxiv.org/abs/2406.08184</a></li>
          <li id="ref-18">Aguvis. “Aguvis: Unified Pure Vision Agents for Autonomous GUI Interaction.” 2024. <a href="https://arxiv.org/abs/2412.04454" target="_blank" rel="noopener">https://arxiv.org/abs/2412.04454</a></li>
          <li id="ref-19">UI-R1. “Enhancing Action Prediction of GUI Agents by Reinforcement Learning.” 2025. <a href="https://arxiv.org/abs/2503.21620" target="_blank" rel="noopener">https://arxiv.org/abs/2503.21620</a></li>
        </ol>
      </div>

      <footer class="post-footer">
        <ul class="post-tags">
          <li><a href="https://junkuanliu.github.io/tags/gui-agents/">gui agents</a></li>
          <li><a href="https://junkuanliu.github.io/tags/reinforcement-learning/">reinforcement learning</a></li>
          <li><a href="https://junkuanliu.github.io/tags/vision-language-models/">vision-language models</a></li>
        </ul>
      </footer>
    </article>
  </main>

  <footer class="footer"></footer>
  <a href="#top" aria-label="Go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
      <path d="M12 6H0l6-6z" />
    </svg>
  </a>

  <script>
    let menu = document.getElementById('menu')
    if (menu) {
      menu.scrollLeft = localStorage.getItem("menu-scroll-position");
      menu.onscroll = function () {
        localStorage.setItem("menu-scroll-position", menu.scrollLeft);
      }
    }
  </script>
  <script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
      if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
        mybutton.style.visibility = "visible";
        mybutton.style.opacity = "1";
      } else {
        mybutton.style.visibility = "hidden";
        mybutton.style.opacity = "0";
      }
    };
  </script>
  <script>
    // Upgrade in-text citation links (e.g., <a href="#ref-3">[3]</a>)
    // to point directly to the first external URL inside the matching reference item.
    (function(){
      document.querySelectorAll('a[href^="#ref-"]').forEach(function(a){
        var id = a.getAttribute('href').slice(1); // e.g., ref-3
        var li = document.getElementById(id);
        if (!li) return;
        var ext = li.querySelector('a[href^="http"]');
        if (ext && ext.href) {
          a.setAttribute('href', ext.href);
          a.setAttribute('target', '_blank');
          a.setAttribute('rel', 'noopener');
        }
      });
    })();
  </script>
  <script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
      if (document.body.className.includes("dark")) {
        document.body.classList.remove('dark');
        localStorage.setItem("pref-theme", 'light');
      } else {
        document.body.classList.add('dark');
        localStorage.setItem("pref-theme", 'dark');
      }
    })
  </script>
</body>

</html>
